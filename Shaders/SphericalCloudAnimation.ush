// VCET Spherical Cloud Animation - Custom HLSL Include
// =====================================================
// 
// To use in your material:
// 1. Add a Custom node
// 2. Include this file or copy the functions
// 3. Call the appropriate function
//
// Material Parameter Collection Parameters needed:
// - CloudTime (Scalar)
// - EquatorWindSpeed (Scalar)
// - PolarWindSpeed (Scalar)
// - WindReversalLatitude (Scalar)
// - TurbulenceStrength (Scalar)
// - TurbulenceScale (Scalar)
// - FlowPhase1 (Scalar)
// - FlowPhase2 (Scalar)
// - FlowBlendFactor (Scalar)

// ============================================
// WIND DIRECTION
// ============================================
// Returns wind direction based on latitude
// Simulates trade winds, westerlies, and polar easterlies
// 
// Latitude: 0 = south pole, 0.5 = equator, 1 = north pole
// ReversalLat: latitude band where wind reverses (~0.15-0.3)
// Returns: -1 (west) to 1 (east)

float VCET_GetWindDirection(float Latitude, float ReversalLat)
{
    float DistFromEquator = abs(Latitude - 0.5);
    
    // Trade winds near equator: east (+1)
    // Westerlies at mid-latitudes: west (-1)  
    // Polar easterlies: east (+0.5)
    
    float WindDir = 1.0;
    if (DistFromEquator > ReversalLat && DistFromEquator < ReversalLat * 2.3)
    {
        WindDir = -1.0;
    }
    else if (DistFromEquator >= ReversalLat * 2.3)
    {
        WindDir = 0.5;
    }
    
    return WindDir;
}

// ============================================
// WIND SPEED
// ============================================
// Returns wind speed multiplier based on latitude
// Faster at equator, slower at poles (Coriolis effect)
//
// Latitude: 0 = south pole, 0.5 = equator, 1 = north pole
// Returns: 0-1 speed multiplier

float VCET_GetWindSpeed(float Latitude)
{
    float DistFromEquator = abs(Latitude - 0.5) * 2.0;
    return 1.0 - DistFromEquator * DistFromEquator;
}

// ============================================
// ANIMATED CLOUD UV
// ============================================
// Main function to get animated cloud UVs
//
// UV: Input equirectangular UV
// Time: Current time in seconds
// EquatorSpeed: Wind speed at equator
// PolarSpeed: Wind speed at poles
// ReversalLat: Latitude where wind reverses
// TurbStrength: Turbulence distortion strength
// TurbScale: Turbulence pattern scale
// 
// Returns: Animated UV coordinates

float2 VCET_AnimateCloudUV(
    float2 UV,
    float Time,
    float EquatorSpeed,
    float PolarSpeed,
    float ReversalLat,
    float TurbStrength,
    float TurbScale)
{
    float Latitude = UV.y;
    
    // Get wind parameters
    float WindDir = VCET_GetWindDirection(Latitude, ReversalLat);
    float SpeedMult = VCET_GetWindSpeed(Latitude);
    float WindSpeed = lerp(PolarSpeed, EquatorSpeed, SpeedMult);
    
    // Base wind offset
    float2 Offset = float2(Time * WindSpeed * WindDir, 0);
    
    // Turbulence (curl noise approximation)
    float TurbPhase = Time * 0.01;
    float2 TurbOffset;
    TurbOffset.x = sin(UV.x * TurbScale * 6.28318 + TurbPhase) * TurbStrength;
    TurbOffset.y = cos(UV.y * TurbScale * 6.28318 + TurbPhase * 1.3) * TurbStrength * 0.5;
    
    float2 AnimatedUV = UV + Offset + TurbOffset;
    
    // Wrap longitude, clamp latitude
    AnimatedUV.x = frac(AnimatedUV.x);
    AnimatedUV.y = saturate(AnimatedUV.y);
    
    return AnimatedUV;
}

// ============================================
// TWO-PHASE FLOWMAP ANIMATION
// ============================================
// Prevents texture stretching with two-phase blending
//
// UV: Input UV
// FlowDir: Flow direction (from flowmap, remapped to -1,1)
// Phase1, Phase2: Pre-calculated phases from MPC
// BlendFactor: Pre-calculated blend from MPC
// Strength: Flow distortion strength
//
// OutUV1, OutUV2: Output UVs to sample
// Returns: Blend factor

void VCET_ApplyFlowmap(
    float2 UV,
    float2 FlowDir,
    float Phase1,
    float Phase2,
    float Strength,
    out float2 OutUV1,
    out float2 OutUV2,
    out float OutBlend)
{
    OutUV1 = UV + FlowDir * Phase1 * Strength;
    OutUV2 = UV + FlowDir * Phase2 * Strength;
    OutBlend = abs(Phase1 - 0.5) * 2.0;
}

// ============================================
// COMPLETE CLOUD ANIMATION
// ============================================
// All-in-one function combining wind and flowmap
//
// UV: Input UV
// CloudTex: Cloud texture
// CloudSampler: Texture sampler
// FlowTex: Flowmap texture (optional, pass CloudTex if not using)
// Time, speeds, etc: Animation parameters
//
// Returns: Final sampled cloud value

float4 VCET_SampleAnimatedCloud(
    float2 UV,
    Texture2D CloudTex,
    SamplerState CloudSampler,
    float Time,
    float EquatorSpeed,
    float PolarSpeed,
    float ReversalLat,
    float TurbStrength,
    float TurbScale,
    float FlowPhase1,
    float FlowPhase2,
    float FlowBlendFactor)
{
    // Animate UV with wind
    float2 AnimUV = VCET_AnimateCloudUV(UV, Time, EquatorSpeed, PolarSpeed, ReversalLat, TurbStrength, TurbScale);
    
    // Two-phase sampling for smooth animation
    float2 UV1 = AnimUV;
    float2 UV2 = AnimUV;
    UV1.x = frac(UV1.x + FlowPhase1 * 0.1);
    UV2.x = frac(UV2.x + FlowPhase2 * 0.1);
    
    float4 Cloud1 = CloudTex.Sample(CloudSampler, UV1);
    float4 Cloud2 = CloudTex.Sample(CloudSampler, UV2);
    
    return lerp(Cloud1, Cloud2, FlowBlendFactor);
}

// ============================================
// CORIOLIS ROTATION (for cyclones)
// ============================================
// Rotates flow direction based on hemisphere
// Northern hemisphere: counter-clockwise cyclones
// Southern hemisphere: clockwise cyclones
//
// FlowDir: Input flow direction
// Latitude: 0-1 (0.5 = equator)
// Returns: Rotated flow direction

float2 VCET_ApplyCoriolisRotation(float2 FlowDir, float Latitude)
{
    // Hemisphere: -1 = south, +1 = north
    float Hemisphere = sign(Latitude - 0.5);
    
    // Rotation angle (stronger at poles)
    float CoriolisStrength = abs(Latitude - 0.5) * 2.0;
    float Angle = Hemisphere * CoriolisStrength * 0.5; // Radians
    
    // 2D rotation
    float CosA = cos(Angle);
    float SinA = sin(Angle);
    float2 Rotated;
    Rotated.x = FlowDir.x * CosA - FlowDir.y * SinA;
    Rotated.y = FlowDir.x * SinA + FlowDir.y * CosA;
    
    return Rotated;
}
